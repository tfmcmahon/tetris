{"version":3,"sources":["utils/tetrominos.js","utils/gameHelpers.js","components/Cell.component.js","components/Stage.component.js","components/Display.component.js","components/StartButton.component.js","components/Tetris.component.js","utils/useInterval.hook.js","App.js","index.js"],"names":["tetrominos","0","shape","color","I","J","L","O","S","T","Z","getRandomTetromino","randomTetromino","Math","floor","random","length","createStage","Array","from","fill","collisionDetection","player","stage","moveX","x","moveY","y","position","tetromino","React","memo","type","className","style","background","border","borderBottomColor","borderRightColor","borderLeftColor","borderTopColor","Stage","gridTemplateRows","gridTemplateColumns","map","row","cell","key","Display","gameOver","text","StartButton","callback","onClick","Tetris","useState","collision","setPlayer","rotateTetromino","matrix","direction","rotatedTetromino","value","index","column","reverse","updatePlayerPosition","prev","resetPlayer","useCallback","stageWidth","setStage","rowsCleared","setRowsCleared","useEffect","updateStage","prevStage","newStage","forEach","reduce","accumulator","findIndex","unshift","push","removeRows","score","setScore","rows","setRows","level","setLevel","calculateScore","linePoints","dropTime","setDropTime","setGameOver","movePlayer","drop","moveTetromino","keyCode","playerCopy","JSON","parse","stringify","pos","offset","rotatePlayer","delay","savedCallback","useRef","current","id","setInterval","clearInterval","useInterval","role","tabIndex","onKeyDown","event","onKeyUp","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.68096028.chunk.js","sourcesContent":["export const tetrominos = {\r\n  //blank cell\r\n  0: {\r\n    shape: [[0]],\r\n    color: '#303030'\r\n  },\r\n  I: {\r\n    shape: [\r\n      [0, 'I', 0, 0],\r\n      [0, 'I', 0, 0],\r\n      [0, 'I', 0, 0],\r\n      [0, 'I', 0, 0]\r\n    ],\r\n    color: '#E0B4FF'\r\n  },\r\n  J: {\r\n    shape: [\r\n      [0, 'J', 0],\r\n      [0, 'J', 0],\r\n      ['J', 'J', 0]    \r\n    ],\r\n    color: '#3DBEA8'\r\n  },\r\n  L: {\r\n    shape: [\r\n      [0, 'L', 0],\r\n      [0, 'L', 0],\r\n      [0, 'L', 'L']\r\n    ],\r\n    color: '#412485'\r\n  },\r\n  O: {\r\n    shape: [\r\n      ['O', 'O'],\r\n      ['O', 'O']\r\n    ],\r\n    color: '#7D0000'\r\n  },\r\n  S: {\r\n    shape: [\r\n      [0, 'S', 'S'],\r\n      ['S', 'S', 0],\r\n      [0, 0, 0]\r\n    ],\r\n    color: '#7B7484'\r\n  },\r\n  T: {\r\n    shape: [\r\n      [0, 0, 0],\r\n      ['T', 'T', 'T'],\r\n      [0, 'T', 0]\r\n\r\n    ],\r\n    color: '#00669D'\r\n  },\r\n  Z: {\r\n    shape: [\r\n      ['Z', 'Z', 0],\r\n      [0, 'Z', 'Z'],\r\n      [0, 0, 0]\r\n    ],\r\n    color: '#91028B'\r\n  }\r\n}\r\n\r\nexport const getRandomTetromino = () => {\r\n  const tetrominosString = 'IJLOSTZ' //String with all keys of the tetrominos besides the blank(starter)\r\n  const randomTetromino = tetrominosString[Math.floor(Math.random() * tetrominosString.length)] //get a random letter/key from the string\r\n  return tetrominos[randomTetromino] //access the tetrominos object with the random key\r\n}","export const stageWidth = 10\r\nexport const stageHeight = 20\r\n\r\nexport const createStage = () => {\r\n  //create multi-dimensional array to represent play area\r\n  return Array.from(\r\n    //create an array with an amount of rows equal to our height...\r\n    Array(stageHeight), () => {\r\n      //...each row unit is filled with an array whose length is equal to our width\r\n      return new Array(stageWidth).fill(\r\n        //each width cell is an array with 0 and a string to represent collision\r\n        [0, 'clear']\r\n      )\r\n    }\r\n  )\r\n}\r\n\r\nexport const collisionDetection = (player, stage, { x: moveX, y: moveY }) => {\r\n  let { position, tetromino } = player\r\n  //loop through the tetromino row\r\n  for (let y = 0; y < tetromino.length; y++) {\r\n    //loop through each unit of each row\r\n    for (let x = 0; x < tetromino[y].length; x++) {\r\n      //check that we are on a cell occupied by a tetromino\r\n      if (tetromino[y][x] !== 0) {\r\n        //prevent movement outside of the stage brounds\r\n        if (\r\n          //check that we are inside the stage bounds (y) ...\r\n          !stage[y + position.y + moveY] ||\r\n          //check that we are inside the stage bounds (x) ... \r\n          !stage[y + position.y + moveY][x + position.x + moveX] ||\r\n          //check that the cell we are moving to isn't set to clear\r\n          stage[y + position.y + moveY][x + position.x + moveX][1] !== 'clear'\r\n        ) { return true }\r\n\r\n      }\r\n    }\r\n  }\r\n}","import React from 'react'\r\n\r\nimport { tetrominos } from '../utils/tetrominos'\r\n\r\nconst Cell = ({ type }) => (\r\n  <div\r\n    className='cell'\r\n    style={{ \r\n      background: tetrominos[type].color,\r\n      border: type === 0 ? '1px solid' : '4px solid',\r\n      borderBottomColor: type === 0 ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.5)',\r\n      borderRightColor: type === 0 ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.5)',\r\n      borderLeftColor: type === 0 ? 'rgba(255, 255, 255, 0.05)' : 'rgba(255, 255, 255, 0.7)',\r\n      borderTopColor: type === 0 ? 'rgba(255, 255, 255, 0.05)' : 'rgba(255, 255, 255, 0.7)'\r\n    }}\r\n    type={type}\r\n  >\r\n  </div>\r\n)\r\n\r\nexport default React.memo(Cell)","import React from 'react'\r\nimport Cell from './Cell.component'\r\n\r\nimport { stageWidth, stageHeight } from '../utils/gameHelpers'\r\n\r\n\r\nconst Stage = ({ stage }) => (\r\n  <div\r\n    className='stage'\r\n    style={{\r\n      gridTemplateRows: `repeat(\r\n        ${stageHeight}, \r\n        calc(38vw / ${stageWidth})\r\n      )`,\r\n      gridTemplateColumns: `repeat(${stageWidth}, 1fr)`\r\n    }}\r\n  >\r\n    {/*map through cells to create stage*/}\r\n    {\r\n       stage.map(row => \r\n        row.map((cell, x) => \r\n          //type is the number value we assign to the cell array\r\n          <Cell \r\n            key={x} \r\n            type={cell[0]}\r\n          />\r\n        )\r\n      )\r\n    }\r\n  </div>\r\n)\r\n\r\nexport default Stage","import React from 'react'\r\n\r\n\r\nconst Display = ({ gameOver, text }) => (\r\n  <div\r\n    style={{\r\n      color: gameOver ? 'red' : '#eee'\r\n    }}\r\n    className='display'\r\n  >\r\n    {text}\r\n  </div>\r\n)\r\n\r\nexport default Display","import React, { Fragment } from 'react'\r\n\r\n\r\nconst StartButton = ({ callback }) => (\r\n  <Fragment>\r\n    <button\r\n      className='startButton'\r\n      onClick={callback}\r\n    >\r\n      Start Game\r\n    </button>\r\n  </Fragment>\r\n)\r\n\r\nexport default StartButton","import React, { useState, useCallback, useEffect } from 'react'\r\n\r\n//utility functions\r\nimport { getRandomTetromino, tetrominos } from '../utils/tetrominos'\r\nimport { createStage, stageWidth, collisionDetection } from '../utils/gameHelpers'\r\nimport { useInterval } from '../utils/useInterval.hook'\r\n\r\n//components\r\nimport Stage from './Stage.component'\r\nimport Display from './Display.component'\r\nimport StartButton from './StartButton.component'\r\n\r\nconst Tetris = () => {\r\n  //set up tetromino movement and rotation\r\n  const [player, setPlayer] = useState({\r\n    position: { x: 0, y: 0 },\r\n    tetromino: tetrominos[0].shape, // get the blank tetromino, use the state key from the object\r\n    collision: false\r\n  })\r\n  //destructure state\r\n  let { position, tetromino, collision } = player\r\n\r\n  const rotateTetromino = (matrix, direction) => {\r\n    //transform the rows into columns\r\n    const rotatedTetromino = matrix.map(\r\n      (value, index) => matrix.map(\r\n        column => column[index]\r\n      )\r\n    )\r\n    //reverse each row\r\n    if (direction > 0) return rotatedTetromino.map(row => row.reverse())\r\n    return rotatedTetromino.reverse()\r\n  }\r\n\r\n  const rotatePlayer = (stage, direction) => {\r\n    const playerCopy = JSON.parse(JSON.stringify(player))\r\n    playerCopy.tetromino = rotateTetromino(playerCopy.tetromino, direction)\r\n\r\n    const pos = position.x\r\n    let offset = 1\r\n\r\n    while (collisionDetection(playerCopy, stage, { x: 0, y: 0 })) {\r\n      playerCopy.position.x += offset\r\n      offset = -(offset + (offset > 0 ? 1 : -1))\r\n      if (offset > playerCopy.tetromino[0].length) {\r\n        rotateTetromino(playerCopy.tetromino, -direction)\r\n        playerCopy.position.x = pos\r\n        return\r\n      }\r\n    }\r\n\r\n    setPlayer(playerCopy)\r\n  }\r\n\r\n  const updatePlayerPosition = ({ x, y, collision }) => {\r\n    setPlayer(prev => ({\r\n      ...prev,\r\n      position: {\r\n        x: prev.position.x += x/2,\r\n        y: prev.position.y += y/2\r\n      },\r\n      collision\r\n    }))\r\n  }\r\n\r\n  const resetPlayer = useCallback(() => {\r\n    setPlayer({\r\n      position: { \r\n        x: stageWidth / 2 - 1, \r\n        y: 0 \r\n      },\r\n      tetromino: getRandomTetromino().shape,\r\n      collision: false\r\n    })\r\n  }, [])\r\n\r\n  //set up stage \r\n  const [stage, setStage] = useState(createStage())\r\n  const [rowsCleared, setRowsCleared] = useState(0)\r\n\r\n  useEffect(() => {\r\n    setRowsCleared(0)\r\n\r\n    const removeRows = newStage => (\r\n      newStage.reduce((accumulator, row) => {\r\n        //check if an entire row is filled with non 0 cells by running findIndex\r\n        if (row.findIndex(cell => cell[0] === 0) === -1) {\r\n          //tally the rows cleared\r\n          setRowsCleared(prev => prev + 0.5)\r\n          //add blank rows to the top of the stage while skipping the filled row to simulate the row clear\r\n          accumulator.unshift(new Array(newStage[0].length).fill([0, 'clear']))\r\n          return accumulator\r\n        }\r\n        //else add the row back in to the stage\r\n        accumulator.push(row)\r\n        return accumulator\r\n      }, [])\r\n    )\r\n\r\n    const updateStage = prevStage => {\r\n      //First redraw/clear the stage\r\n      const newStage = prevStage.map(row =>\r\n        //map through the rows, then to each cell\r\n        row.map(cell => \r\n          //grab the string value of the cell array\r\n          (\r\n            cell[1] === 'clear'\r\n              ? [0, 'clear']\r\n              : cell\r\n          )\r\n        )\r\n      )\r\n\r\n      //draw the tetromino\r\n      tetromino.forEach(\r\n        //loop through the parent array for all of the rows, the index is the height (y)\r\n        (row, y) => {\r\n          row.forEach(\r\n            //loop through each row, the index is the width (x)\r\n            (value, x) => {\r\n              if (value !== 0) {\r\n                // update the area of the tetromino, build the tetromino based on incoming coordinates and the player position\r\n                newStage[y + position.y][x + position.x] = [\r\n                  value,\r\n                  `${collision ? 'merged' : 'clear'}`\r\n                ]\r\n              }\r\n            }\r\n          )\r\n        }\r\n      )\r\n\r\n      //then check if we collided with anything\r\n      if (collision) {\r\n        //generate the next block\r\n        resetPlayer()\r\n        return removeRows(newStage)\r\n      }\r\n\r\n      return newStage\r\n\r\n    }\r\n\r\n    setStage(prev => updateStage(prev))\r\n\r\n  }, [position, tetromino, collision, resetPlayer])\r\n\r\n  //set up game status\r\n  const [score, setScore] = useState(0)\r\n  const [rows, setRows] = useState(0)\r\n  const [level, setLevel] = useState(0)\r\n\r\n  const calculateScore = useCallback(() => {\r\n    const linePoints = [40, 100, 300, 1200]\r\n    //check for score\r\n    if (rowsCleared > 0) {\r\n      setScore(prev => prev + linePoints[rowsCleared - 1] * (level + 1))\r\n      setRows(prev => prev + rowsCleared)\r\n    }\r\n  }, [level, rowsCleared])\r\n\r\n  useEffect(() => {\r\n    calculateScore()\r\n  }, [calculateScore, rowsCleared, score])\r\n\r\n  //set up the tetromino falling speed\r\n  const [dropTime, setDropTime] = useState(null)\r\n\r\n  //set up game reset\r\n  const [gameOver, setGameOver] = useState(false)\r\n\r\n  const movePlayer = direction => {\r\n    if (!collisionDetection(player, stage, { x: direction, y: 0 })) {\r\n      updatePlayerPosition({\r\n        x: direction,\r\n        y: 0\r\n      })\r\n    }\r\n  }\r\n\r\n  const startGame = () => {\r\n    //reset everything\r\n    setStage(createStage())\r\n    setDropTime(1000)\r\n    resetPlayer()\r\n    setGameOver(false)\r\n    setScore(0)\r\n    setRows(0)\r\n    setLevel(0)\r\n  }\r\n\r\n  const drop = () => {\r\n    //increase level every 10 rows\r\n    if (rows > (level + 1) * 10) {\r\n      setLevel(prev => prev + 1)\r\n      //increate interval speed\r\n      setDropTime(1000 / (level + 1) + 200)\r\n    }\r\n\r\n    if (!collisionDetection(player, stage, { x: 0, y: 1 })) {\r\n      updatePlayerPosition({\r\n        x: 0, \r\n        y: 1, \r\n        collision: false\r\n      })\r\n   } else {\r\n    //check for game over\r\n    if (position.y < 1) {\r\n      setGameOver(true)\r\n      setDropTime(null)\r\n    }\r\n    //set block collision\r\n     updatePlayerPosition({\r\n       x: 0,\r\n       y: 0,\r\n       collision: true\r\n     })\r\n   }\r\n  }\r\n\r\n  const keyUp = ({ keyCode }) => {\r\n    if(!gameOver) {\r\n      if (keyCode === 40 || keyCode === 83) {\r\n        setDropTime(1000 / (level + 1) + 200)\r\n      }\r\n    }\r\n  }\r\n\r\n  const dropPlayer = () => {\r\n    setDropTime(null)\r\n    drop()\r\n  }\r\n\r\n  const moveTetromino = ({ keyCode }) => {\r\n    //left arrow, a = 37, 65\r\n    //right arrow, d = 39, 68\r\n    //up arrow, w = 38, 87\r\n    //down arrow, s = 40, 83\r\n\r\n    if (!gameOver) {\r\n      if (keyCode === 37 || keyCode === 65) {\r\n        movePlayer(-1)\r\n      } else if (keyCode === 39 || keyCode === 68) {\r\n        movePlayer(1)\r\n      } else if (keyCode === 40 || keyCode === 83) {\r\n        dropPlayer()\r\n      } else if (keyCode === 38 || keyCode === 87) {\r\n        rotatePlayer(stage, 1)\r\n      }\r\n    }\r\n  }\r\n\r\n  useInterval(() => {\r\n    drop()\r\n  }, dropTime)\r\n\r\n  return (\r\n    <div \r\n      className='tetrisWrapper'\r\n      role='button'\r\n      tabIndex='0'\r\n      onKeyDown={event => moveTetromino(event)}\r\n      onKeyUp={keyUp}\r\n    >\r\n      <div className='tetris'>\r\n        <Stage stage={stage}/>\r\n        <aside>\r\n          {gameOver \r\n          ? (\r\n              <Display gameOver={gameOver} text=\"Game Over\" />\r\n            )\r\n          : (\r\n              <div>\r\n                <Display text={`Score: ${score}`} />\r\n                <Display text={`Rows Cleared: ${rows}`} />\r\n                <Display text={`Level: ${level}`} />\r\n              </div>\r\n            )\r\n          }\r\n          <StartButton callback={startGame}/>\r\n        </aside>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default Tetris","import { useEffect, useRef } from 'react';\n\nexport function useInterval(callback, delay) {\n  const savedCallback = useRef();\n  // Remember the latest callback.\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  // Set up the interval.\n  useEffect(() => {\n    function tick() {\n      savedCallback.current();\n    }\n    if (delay !== null) {\n      const id = setInterval(tick, delay);\n      return () => {\n        clearInterval(id);\n      };\n    }\n  }, [delay]);\n}\n","import React from 'react'\nimport Tetris from './components/Tetris.component'\nimport './App.css'\n\nconst App = () => (\n  <div className='app-wrapper'>\n    <Tetris />\n  </div>\n)\n\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}